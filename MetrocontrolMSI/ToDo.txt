ToDo
=====

- развёртывания crystal reports runtime для Метроконтроля - отдельной политикой
- осталось разобраться с публикацией лишних глаголов
- всё-таки попробовать спрятать окно powershell

History
=======

+ ну и подготовить bat файлы сразу для подготовки административной точки установки для пользователей отдельно (без интерфейса), отдельно - для администраторов (с интерфейсом)
+ свойствами запретить пользователям изменять состав продуктов на машинах
+ так же при установке csmadmin необходимо глагол edit (OpenWithProgId inifile в windows 8 не подходит), чтобы можно было его открыть в редакторе.
+ При установке компонента csmadmin имеет смысл добавить и [shellnew](.http://msdn.microsoft.com/en-us/library/windows/desktop/cc144101(v=vs.85).aspx) для нашего типа файла 
+ протестировать ярлыки с указанием приложения
+ убрать eula из интерфейса
+ По поводу окна powershell: стили не поддерживались powershell 1.0. Так что есть смысл изменить поиск powershell.exe, оставить только 3ю версию, и поколдовать с явным заданием версии.

- включить в политике mysql правило для входящих tcp соединений

- политику развёртывания компонентов ОС, в частности - .net 2.0

+ иконка для справки

- автосборка .msi пакета при замене форм / файлов + автообновление политики

- параметры, в том числе - параметры подключения - в профиле пользователя C:\Users\admin-sergey.s.betke\AppData\Local\IFirst\MetrControl. Необходимо:

- Мы разворачиваем БАЗЫ (как и с 1С). Регистрировать имеет смысл некий тип файла, в котором и будут реальные параметры подключения. Файл - ini мне кажется лучшим вариантом (им можно рулить через GPO+GPP). Создаём свой скрипт, который и будем запускать вместо метроконтроля, которому будем скармливать этот файл. Скрипт будет из файла перекачивать данный в конфигурационный файл в профиле пользователя и запускать Метроконтроль. А ярлыки в таком случае - на конкретные файлы нашего типа. 

При таком подходе мы будем публиковать ярлыки сразу на базы, и можно иметь несколько баз сразу, доступных пользователю, что иногда требуется. 

попробовать переписать подключение к базе на подключение через ODBC. Connection string? Рискну предположить, что может потребоваться переписать sqlc.dll для реализации этой задачи. Идеальное решение - подключение ODBC указываем в реестре (с учётом возможного применения политик), и дальше подключаемся к базе уже через odbc. И самое подключение настраиваем через GPO. И всё в ажуре.

Варианта без переписывания sqlc.dll перейти на ODBC подключения с возможностью администрирования через GPO я не вижу. Переместить настройки подключения в All Users тоже нет возможности - программа ищет только в профиле пользователя. Поэтому пока вижу смысл только в реализации решения через свой тип файла, как действовал и для 1С.

Предлагаю тип файла .csmdb. Файл по структуре можно использовать как .ini, так и xml. ini файл более удобен для случае, если придётся такие файлы создавать на машинах. 

В качестве обработчика такого типа файлов придётся регистрировать скрипт. Но сценарий имеет смысл подписать. Обязательно. Чтобы в принципе не возникало проблем с безопасностью при исполнении сценариев на машинах домена. 

Скрипт на вход будет получать полный путь к .csmdb файлу и дополнительные аргументы. Задача скрипта - прочитать содержимое из указанного .csmdb файла, перезаписать файл CnnSettings.xml в профиле пользователя параметрами подключения, указанными в файле .csmdb, после чего вызывать csmmain.exe. 

Но это не всё. По одному .csmdb файлу мы должны иметь возможность запустить как непосредственно Метроконтроль, так и систему учёта клейм, инструменты администратора.

Первое, что для этого следует сделать - определить разные глаголы для типа файлов .csmdb (+1 глагол для средств администрирования, +1 - для учёта клейм).

Но как при этом создать ярлык, при выполнении глагола по умолчанию на котором мы сможем запустить систему учёта клейм? совсем не хочется для этих целей создавать ещё один тип файла, как и дублировать файлы с настройками подключения к БД также неразумно. Решение необходимо найти.

Второе решение: через GPO мы будем создавать ярлык, который будет ссылаться не на .csmdb файл, а на наш сценарий, в командной строке которого мы уже будем указывать дополнительные аттрибуты (в частности - глагол). 

Итого, так как мы будем создавать ярлыки через GPO на файлы .csmdb и на скрипты непосредственно, необходимо ввести свойство в MSI, которое предотвратит публикацию ярлыков. А также необходимо предусмотреть ряд свойств, которые позволят опубликовать ярлыки на конкретную базу данных.

Путь к сценарию в ярлыке задавать не будем. Путь к нему пропишем в реестре в App Paths.

powershell запускать нужно будет с параметрами:

-WindowStyle Hidden -File <file.ps1> -CSMDB <file.csmdb> -Tool MarkInv

Так же можно указать и ExecutionPolicy, но лучше подписать сценарий, это будет куда разумнее.

Но при таком подходе необходимо знать полный путь к файлу сценария при создании ярлыка, что не очень хорошо... 

Следует опробовать следующее решение: определить тип файла .csmdb. И при создании ярлыка на него попробовать указать параметры после его имени файла. И проверить в сценарии - будут ли переданы параметры ему. при описании глагола для нашего типа файла как раз и следует попробовать определить наличие дополнительных параметров и их передать сценарий. А в качестве параметра - как раз инструмент, которым мы хотим "обработать" нашу базу.

Такой путь мне кажется наиболее оптимальным. Его и будет испытывать. Его преимущество в том числе в том, что при обработке ярлыка будут использованы механизмы install-on-demand от MSI со всеми вытекающими последствиями.

Так же следует развить эту идею. Да, корректно отработают механизмы восстановления для обработчика типа .csmdb, но только для него, не для тех компонентов, которые на самом деле придётся вызывать сценарию. И чтобы использовать эти механизмы и для конечных компонентов придётся реализовать их вызов через один из поддерживаемых msi механизмов: ярлык (не подходит), CLSID (опять не подходит), ProgID (аналогично), и опять-таки - типы файлов. Посему необходимы эксперименты: попробовать определить каким-либо образом ProgId и из сценария создать объект по ProgId так, чтобы это привело к запуску приложения (вероятнее всего - вариант кривой), либо же определить дополнительный типы файлов, но не создавать их на самом деле, а в сценарии после подготовки параметров подключения в профиле пользователя имитировать вызов глагола по умолчанию для этого типа файлов затем, чтобы обеспечить запуск приложения через механизмы install-on-demand от msi.

Итого:
- пример файла .csmdb
- сценарий .ps1 и параметры к нему
- определение типа файлов .csmdb
- определение дополнительных глаголов к .csmdb
- тестирование механизма install-on-demand

!!! Тип файла необходимо делать version specific, иначе - каким образом разные версии метроконтроля на одной машине эксплуатировать? Либо универсальный скрипт рисовать и в файле прописывать необходимую версию, либо же создавать типы файлов типа .csmdb-23 в дополнение к .csmdb (собственно говоря, csmdb-23 уже будет ближе к progid (кстати - а AppId здесь не применим?)).

Начнём с первого шага: необходимо обеспечить возможность опционально отключать создание ярлыков.
Чтобы отключить все ярлыки, достаточно для действия CreateShortcuts дописать условие. Sequence - 4500. Но это действие применимо для отключения всех ярлыков. Для этих целей ввёл свойство DISABLESHORTCUTS (должно быть ="Yes").
Можно было бы отключить и по одному ярлыку, разместив их в отдельных компонентах. Но при этом не будет возможности использовать advertised ярлыки, что крайне целесообразно с моей точки зрения.

Для отключения ярлыков по одиночке использовать компоненты не получится по описанным выше причинам. Пока в качестве самого простого решения с сохранением механизма install-on-demand я вижу следующее: через custom action мы переопределим свойства, отвечающие за каталоги установки ярлыков, на TempFolder.

Описанное решение реализовано.

И нужно разобраться с глаголами - запретить их массовое применение, только индивидуальное.

Напрашивается такое решение:

Определить дополнительный глагол Run плюсом к Open нашим типам файлов. Для глагола Run указать флаг ProgrammaticAccessOnly - в результате его не будет в интерфейсе, только из скрипта смогу его использовать. И вот для чего: по глаголу Open я открываю скрипт bootstapper, который вызовет реальное приложение через глагол Run уже. 

Чтобы избежать проблем с вызовом сценариев .ps1 с учётом install-on-demand лучше его в .exe сконвертировать. Для этого есть решения:

http://rkeithhill.wordpress.com/2010/09/21/make-ps1exewrapper/
http://ps2exe.codeplex.com/

Итого, отдельным проектом собираем .exe из .ps1 скрипта, и используем этот .exe уже полноценно как advertised verb.

Можно в принципе уйти от лишних типовы файлов, которые я, по сути, ради Darwin Descriptor в глаголах и создаю. Вместо этого можно использовать MSI API:
http://msdn.microsoft.com/en-us/library/aa302344.aspx
для install-on-demand и прочих прелестей. Стоит обратить внимание на MsiProvideComponent - по сути, именно данное API и обеспечит нам и install-on-demand, и получение пути, по которому установлен необходимый нам компонент. По сути, используемый мной сейчас Darwin Descriptor именно эту функцию и использует.

http://msdn.microsoft.com/en-us/library/aa302344.aspx

а здесь - c# обёртка для MSI API 
http://www.java2v.com/Open-Source/CSharp/Installers-Generators/WiX/Microsoft/Deployment/WindowsInstaller/Installer.cs.htm

может всё-таки не усложнять жизнь, и попробовать реализовать возможность использовать именно ps1 скрипт без его "переделки" в exe? Этот вариант мне кажется очень разумным и вполне возможным. Для этих целей необходимо добавить глаголы в .ps1. Естественно - не в рамках данного дистрибутива. 

Итого, процедура:

- для .csmdb23 - вызывает bootstrapper, который генерирует необходимый файл конфигурации, использует самостоятельно MSI API (MsiProvideComponent), чтобы не использовать Darwin Descriptor. И вызывает необходимый инструмент в зависимости от глагола, переданного в качестве аргумента.
- при определении дополнительных глаголов к .csmdb23 так же будем вызывать bootstrapper (так как за счёт прямого использования MSI API мы избавимся от необходимости использовать Darwin дескрипторы в глаголах), но уже при определении этих глаголов мы сразу и укажем в качестве параметра вызываемый инструмент.

P.S> При определении глагола csmadmin необходимо дорисовать UAC щит к этому глаголу.

При таком подходе мы избавляемся от лишних типов файлов, что правильно и хорошо. но при этом следует убедиться, что не последует каскадного применения определений progid!

Необходимый глагол для исполнения .ps1 уже определён:

Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\Microsoft.PowerShellScript.1\Shell\0\Command]
@="\"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" \"-Command\" \"if((Get-ExecutionPolicy ) -ne 'AllSigned') { Set-ExecutionPolicy -Scope Process Bypass }; & '%1'\""

добавить %~ для передачи параметров сценарию - не работает!!!

Посему достаточно только переопределить глагол по умолчанию с open на '0':

[HKEY_CLASSES_ROOT\Microsoft.PowerShellScript.1\Shell]
@="0"

Это действие в дальнейшем я помещу в политику (имеет смысл свой .admx по этому поводу написать). Но в этом дистрибутиве это действие я реализую однозначно, но - по условию! (не по умолчанию).

Имеет смысл изменить права на csmadmin.exe - дать возможность запуска только администраторам, не пользователям.

!!! регистрировать наши глаголы необходимо только отдельными компонентами и опционально, в зависимости от установки приложений. В принципе, все глаголы, кроме open, можно сделать и без поддержки darwin дескрипторов, переживём.

описание возможных параметров для глаголов - в комментариях http://msdn.microsoft.com/en-us/library/windows/desktop/cc144101%28v=vs.85%29.aspx

Предложение следующее. Всё-таки, нарисую я .cmd файл, который и будет опубликован bootstrapper'ом. Именно он будет "подниматься" через дескриптор Дарвина.
Таким образом я постараюсь решить проблему install-on-demand. Но уже прямыми записями в реестр я укажу не .cmd файл, а командную строку для запуска .ps1 скрипта с необходимыми аттрибутами - уже с "погашенным" окном. Таким образом я надеюсь добиться того, что окно .cmd файла возникнет только один раз - при install-on-demand. 

Итого - результат прежний. Если я хочу избежать лишних окон при открытии приложений, необходим exe файл (если я при этом ещё хочу и install-on-demand поддержать).


-------------

а что если попробовать "финт ушами"? То есть: ввести каталог в msi для 
powershell.exe, найти его в процессе установки. Если не найдём - можно ругаться. Но если найдём... 
тогда - меняем ИСХОДНЫЙ каталог (именно - исходный) - на найденный. И для 
этой компоненты - запуск ставим с исходного местоположения. 

Тогда - можно смело использовать powershell.exe в роли того .exe файла, который я хотел использовать. и darwin дескрипторы будут работать, и никаких лишних
экзешников ложить в дистрибутив не требуется.

Этот путь пока недостижим. не нашёл я возможности установить исходный каталог для конкретного каталога. 
Однако, можно попробовать создать компонент с флагом msidbComponentAttributesNeverOverwrite, и вложить "пустой" powershell.exe в дистрибутив. Тогда файл будет обнаружен, и проблем, по идее, не должно возникнуть. Однако, в справке написано чётко: не используйте этот флаг с компонентами, которые регистрируются через AppId, Class, Extension, ProgId, MIME, and Verb tables, а мне как раз это и требуется. Надо попробовать в любом случае, возможно - подойдёт решение и такое.

Однако - такой путь подошёл!

-----------------

для того, чтобы спрятать ненужные глаголы (если соответствующее приложение даже не опубликовано) - буду использовать флаг ProgrammaticAccessOnly. Да, это не тоже самое, но через меню до него будет не добраться.

------------------
